package intransix.osm.termite.render;

import javax.swing.*;
import javax.swing.table.*;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import intransix.osm.termite.render.MapLayer;
import java.util.*;
import java.awt.Component;

/**
 *
 * @author sutter
 */
public class LayerManagerPanel extends JPanel {
	
	private final static int LAYER_COLUMN = 0;
	private final static int OPACITY_COLUMN = 1;

	/**
	 * Creates new form LayerManager
	 */
	public LayerManagerPanel() {
		initComponents();
		OpacityRenderer or = new OpacityRenderer();
		jTable1.setRowHeight(or.getPreferredSize().height);
		jTable1.setDefaultRenderer(Float.class,or);
		or = new OpacityRenderer();
		jTable1.setDefaultEditor(Float.class, or);
	}
	
	/** This method notifies when a layer changes state.
	 * 
	 * @param layer		The layer that changed.
	 * @param layers	The list of all layers.
	 */
	public void layerStateChanged(List<MapLayer> layers) {

		DefaultTableModel model = (DefaultTableModel)jTable1.getModel();
		model.setRowCount(0);
		Object[] row = new Object[2];
		for(MapLayer ml:layers) {
			if((ml.getActiveState())&&(ml.isVisible())) {
				row[LAYER_COLUMN] = ml;
				row[OPACITY_COLUMN] = ml.getOpacity();
				model.addRow(row);
			}
		}
		this.repaint();
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();

        setLayout(new javax.swing.BoxLayout(this, javax.swing.BoxLayout.LINE_AXIS));

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Layer", "Opacity"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Float.class
            };
            boolean[] canEdit = new boolean [] {
                false, true
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jTable1.setRowHeight(70);
        jTable1.getTableHeader().setReorderingAllowed(false);
        jScrollPane1.setViewportView(jTable1);

        add(jScrollPane1);
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable jTable1;
    // End of variables declaration//GEN-END:variables

	//==================
	// edit and render classes
	//==================
	
	public static class OpacityRenderer extends JSlider
                           implements TableCellRenderer, TableCellEditor,
						   ChangeListener {
		
		private final static int RANGE = 100;
		
		private List<CellEditorListener> listeners = new ArrayList<CellEditorListener>();
		private MapLayer activeLayer;

		public OpacityRenderer() {
			super(JSlider.HORIZONTAL,0,RANGE,RANGE);
			setOpaque(true); //MUST do this for background to show up.

			//labels
			this.setLabelTable(this.createStandardLabels(50));
			this.setPaintLabels(true);
			
			this.addChangeListener(this);
		}

		@Override
		public Component getTableCellRendererComponent(
								JTable table, Object opacity,
								boolean isSelected, boolean hasFocus,
								int row, int column) {
			int opacityInt = (int)(((Float)opacity).floatValue() * RANGE);
			this.setValue(opacityInt);
			return this;
		}

		@Override
		public Component getTableCellEditorComponent(JTable table,
										Object opacity,
										boolean isSelected,
										int row,
										int column) {
			activeLayer = (MapLayer)table.getModel().getValueAt(row,LAYER_COLUMN);
			int opacityInt = (int)(((Float)opacity).floatValue() * RANGE);
			this.setValue(opacityInt);
			return this;
		}
		
		@Override
		public Object getCellEditorValue() {
			return getOpacityValue();
		}
		
		public float getOpacityValue() {
			return this.getValue() * (1.0f / RANGE);
		}
		
		@Override
		public boolean isCellEditable(EventObject anEvent) {
			return true;
		}
		
		@Override
		public boolean shouldSelectCell(EventObject anEvent) {
			return true;
		}
		
		@Override
		public boolean stopCellEditing() {
			ChangeEvent changeEvent = new ChangeEvent(this);
			activeLayer = null;
			int cnt = listeners.size();
			for(int i = 0; i < cnt; i++) {
				listeners.get(i).editingStopped(changeEvent);
			}
			return true;
		}
		
		@Override
		public void cancelCellEditing() {
			ChangeEvent changeEvent = new ChangeEvent(this);
			activeLayer = null;
			int cnt = listeners.size();
			for(int i = 0; i < cnt; i++) {
				listeners.get(i).editingCanceled(changeEvent);
			}
		}
		
		@Override
		public void addCellEditorListener(CellEditorListener l) {
			if(!listeners.contains(l)) {
				listeners.add(l);
			}
		}
		
		@Override
		public void removeCellEditorListener(CellEditorListener l) {
			listeners.remove(l);
		}
		
		@Override 
		public void stateChanged(ChangeEvent ce) {
			if(activeLayer != null) {
				activeLayer.setOpacity(getOpacityValue());
				activeLayer.getMapPanel().repaint();
			}
		}
	}
}
